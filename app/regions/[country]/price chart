import { useEffect, useLayoutEffect, useState, useCallback, useMemo, useRef } from 'react';
import { scaleTime, scaleLinear } from '@visx/scale';
import { AxisBottom, AxisRight } from '@visx/axis';
import { GridRows } from '@visx/grid';
import { curveMonotoneX } from '@visx/curve';
import { LinePath } from '@visx/shape';
import { localPoint } from '@visx/event';
import { useTooltip, TooltipWithBounds, defaultStyles } from '@visx/tooltip';
import { bisector } from 'd3-array';

// @ts-ignore - Vite env variables are available at runtime
const API_BASE = import.meta.env.VITE_API_BASE_URL || '/api';

interface PriceChartProps {
  market: any;
  height?: number;
  hideIntervalSelector?: boolean;
  isEmbed?: boolean;
  initialOutcome?: 'YES' | 'NO';
}

interface ChartDataPoint {
  time: number;
  price: number;
  timestamp: string;
  id?: string;
}

// Chart dimensions
const chartHeight = 380;
const chartWidth = 1000; // Will be responsive

export function PriceChart({ market, height = 280, hideIntervalSelector = false, isEmbed = false, initialOutcome }: PriceChartProps) {
  const [interval, setInterval] = useState<'1h' | '6h' | '1d' | '1w' | '1m' | 'max'>('max');
  const [selectedOutcome, setSelectedOutcome] = useState<'YES' | 'NO'>(initialOutcome || 'YES');
  const [chartData, setChartData] = useState<ChartDataPoint[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [dataStaleness, setDataStaleness] = useState<number | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [containerWidth, setContainerWidth] = useState(chartWidth);
  const [hasAttemptedFetch, setHasAttemptedFetch] = useState(false);
  const correctionAttemptedRef = useRef<{ [key: string]: boolean }>({});
  const containerRef = useRef<HTMLDivElement>(null);
  const isLoadingRef = useRef(false);
  const hasAttemptedFetchRef = useRef(false);
  const hasDataRef = useRef(false);

  // Track previous initialOutcome to detect prop changes (not user interactions)
  const prevInitialOutcomeRef = useRef(initialOutcome);
  
  // Update selectedOutcome only when initialOutcome prop changes (not when user clicks)
  useEffect(() => {
    // Only update if initialOutcome prop itself changed (not when selectedOutcome changes)
    if (initialOutcome && prevInitialOutcomeRef.current !== initialOutcome) {
      setSelectedOutcome(initialOutcome);
      prevInitialOutcomeRef.current = initialOutcome;
    } else if (!prevInitialOutcomeRef.current && initialOutcome) {
      // Set initial value on first mount
      setSelectedOutcome(initialOutcome);
      prevInitialOutcomeRef.current = initialOutcome;
    }
  }, [initialOutcome]); // Only depend on initialOutcome, not selectedOutcome

  // Get outcomes array
  const outcomes = Array.isArray(market?.outcomes) 
    ? market.outcomes 
    : (typeof market?.outcomes === 'string' ? JSON.parse(market.outcomes) : ['YES', 'NO']);
  
  const outcomeIndex = outcomes.findIndex((o: string) => 
    o.toUpperCase() === selectedOutcome || 
    (selectedOutcome === 'YES' && (o.toUpperCase() === 'YES' || o.toUpperCase() === 'TRUE')) ||
    (selectedOutcome === 'NO' && (o.toUpperCase() === 'NO' || o.toUpperCase() === 'FALSE'))
  );
  const actualIndex = outcomeIndex >= 0 ? outcomeIndex : (selectedOutcome === 'YES' ? 0 : 1);
  
  const currentPrice = parseFloat(market?.outcomePrices?.[actualIndex] || market?.outcomePrices?.[0] || '0.5') * 100;

  // Check if this is a proposal market
  // IMPORTANT: Only treat as proposal if it has a proposalId
  // Polymarket markets with clobTokenIds should NOT be treated as proposals
  const isProposalMarket = useMemo(() => {
    // If it has clobTokenIds and NO proposalId, it's a Polymarket market, not a proposal
    if (market?.clobTokenIds && !market?.proposalId && !market?.proposal_id) {
      return false;
    }
    // Treat as proposal if it has a proposalId (even if it also has clobTokenIds)
    // This allows proposal charts to use their own history endpoint
    return !!(market?.proposalId || market?.proposal_id || (market?.question_id && market?.question_id.startsWith('prop-')));
  }, [market]);

  const getAssetIdentifier = useCallback((outcomeIdx: number): string | null => {
    if (!market) return null;
    
    // PRIORITY 1: For proposal markets, use proposalId (they have their own history endpoint)
    if (isProposalMarket && (market.proposalId || market.proposal_id || market.question_id)) {
      return market.proposalId || market.proposal_id || market.question_id;
    }
    
    // PRIORITY 2: clobTokenIds (for Polymarket markets only)
    if (market.clobTokenIds) {
      try {
        const ids = Array.isArray(market.clobTokenIds) 
          ? market.clobTokenIds 
          : JSON.parse(market.clobTokenIds);
        
        if (Array.isArray(ids) && ids.length > outcomeIdx && ids[outcomeIdx]) {
          return String(ids[outcomeIdx]);
        }
        
        const otherIdx = outcomeIdx === 0 ? 1 : 0;
        if (Array.isArray(ids) && ids.length > otherIdx && ids[otherIdx]) {
          console.warn(`⚠️ Token ID for outcome ${outcomeIdx} not found, using outcome ${otherIdx} token instead`);
          return String(ids[otherIdx]);
        }
        
        if (Array.isArray(ids) && ids.length > 0 && ids[0]) {
          console.warn(`⚠️ Using first available token ID as fallback:`, ids[0]);
          return String(ids[0]);
        }
      } catch (e) {
        console.error('Failed to parse clobTokenIds:', e);
      }
    }
    
    // PRIORITY 3: Fallback: Try question_id or conditionId (less accurate but may work)
    // Note: These return ALL trades (both YES and NO), so prices may be mixed
    // BUT: Only use if it looks like a token ID (numeric/hex), NOT a slug (contains hyphens)
    if (market.question_id || market.questionID || market.id) {
      const fallbackId = String(market.question_id || market.questionID || market.id);
      // Check if it looks like a slug (contains hyphens) - if so, skip this fallback
      if (fallbackId.includes('-') && !fallbackId.startsWith('0x')) {
        // Silently skip - this is expected for markets without token IDs
      } else {
        // Use fallback but don't warn - this is acceptable for some markets
        return fallbackId;
      }
    }
    
    if (market.conditionId) {
      const conditionIdStr = String(market.conditionId);
      // Check if it looks like a slug
      if (conditionIdStr.includes('-') && !conditionIdStr.startsWith('0x')) {
        // Silently skip - this is expected for markets without token IDs
      } else {
        // Use fallback but don't warn - this is acceptable for some markets
        return conditionIdStr;
      }
    }
    
    // DO NOT use slug as fallback - market-history endpoint requires token ID, question_id, or conditionId
    // Silently return null - this is expected for some markets that don't have token IDs yet
    return null;
  }, [market, selectedOutcome, isProposalMarket]);

  const getMaxPoints = useMemo(() => {
    switch (interval) {
      case '1h': return 200;
      case '6h': return 300;
      case '1d': return 400;
      case '1w': return 500;
      case '1m': return 600;
      case 'max': return 1000;
      default: return 500;
    }
  }, [interval]);

  const downsampleData = useCallback((data: ChartDataPoint[], maxPoints: number): ChartDataPoint[] => {
    if (data.length <= maxPoints) return data;
    
    // LTTB algorithm
    const bucketSize = (data.length - 2) / (maxPoints - 2);
    const sampled: ChartDataPoint[] = [data[0]];
    
    let a = 0;
    for (let i = 0; i < maxPoints - 2; i++) {
      const rangeStart = Math.floor((i + 1) * bucketSize) + 1;
      const rangeEnd = Math.min(Math.floor((i + 2) * bucketSize) + 1, data.length);
      
      let avgX = 0;
      let avgY = 0;
      let avgRangeStart = Math.floor((i) * bucketSize) + 1;
      let avgRangeEnd = rangeStart;
      
      for (let j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].time;
        avgY += data[j].price;
      }
      avgX /= (avgRangeEnd - avgRangeStart);
      avgY /= (avgRangeEnd - avgRangeStart);
      
      let maxArea = -1;
      let maxAreaIndex = rangeStart;
      
      for (let j = rangeStart; j < rangeEnd; j++) {
        const area = Math.abs(
          (data[a].time - avgX) * (data[j].price - data[a].price) -
          (data[a].time - data[j].time) * (avgY - data[a].price)
        ) * 0.5;
        
        if (area > maxArea) {
          maxArea = area;
          maxAreaIndex = j;
        }
      }
      
      sampled.push(data[maxAreaIndex]);
      a = maxAreaIndex;
    }
    
    sampled.push(data[data.length - 1]);
    return sampled;
  }, []);

  const fetchChartData = useCallback(async (assetId: string, outcomeIdx: number) => {
    // Check if this is actually a proposal by looking at the assetId itself
    // Token IDs (clobTokenIds) are long numbers, not proposal IDs
    const isActualProposal = assetId.startsWith('prop-');
    const isProposal = isProposalMarket && isActualProposal;
    
    // Skip if we're already loading the same data
    const fetchKey = `${assetId}-${outcomeIdx}-${interval}`;
    if (isLoadingRef.current && hasAttemptedFetchRef.current) {
      return;
    }
    
    // Validate that assetId is not a slug (slugs contain hyphens, token IDs are hex strings or numbers)
    // Token IDs are typically hex strings (0x...) or very long numbers, not slugs with hyphens
    // Exception: proposal IDs are allowed
    if (!isProposal && assetId && assetId.includes('-') && !assetId.startsWith('0x')) {
      console.error('❌ Invalid asset identifier (looks like a slug, not a token ID):', assetId);
      setIsLoading(false);
      setError('Market data not available - token ID missing');
      setChartData([]);
      return;
    }
    
    // Only set loading if we have no data - keep showing existing data while fetching new data
    if (chartData.length === 0) {
      isLoadingRef.current = true;
      setIsLoading(true);
    }
    hasDataRef.current = false;
    hasAttemptedFetchRef.current = false;
    setHasAttemptedFetch(false);
    // ALWAYS clear error at start of fetch - never show error while loading
    setError(null);
    
    try {
      const apiInterval = interval;
      // Use proposal history endpoint ONLY for actual proposal markets (prop-*)
      // Polymarket markets with token IDs should use market-history endpoint
      // Token IDs are long numbers, not proposal IDs
      const isActualProposal = assetId.startsWith('prop-');
      const url = isActualProposal
        ? `${API_BASE}/proposals/${assetId}/history?interval=${apiInterval}`
        : `${API_BASE}/market-history/${assetId}?interval=${apiInterval}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Clear error only when we successfully get data
      setError(null);
      
      if (data?.ohlcv && Array.isArray(data.ohlcv) && data.ohlcv.length > 0) {
        const outcomePrice = parseFloat(market?.outcomePrices?.[outcomeIdx] || '0') * 100;
        let startTime = 0;
        
        if (interval !== '1m' && interval !== 'max') {
          const now = Date.now();
        switch (interval) {
            case '1h': startTime = now - (1 * 60 * 60 * 1000); break;
            case '6h': startTime = now - (6 * 60 * 60 * 1000); break;
            case '1d': startTime = now - (24 * 60 * 60 * 1000); break;
            case '1w': startTime = now - (7 * 24 * 60 * 60 * 1000); break;
          }
        }
        
        const points: ChartDataPoint[] = data.ohlcv
          .filter((candle: any) => {
            if (!candle || candle.time === undefined || candle.close === undefined) return false;
            // For proposal markets, close is already in percentage (0-100)
            // For regular markets, it's in decimal (0-1)
            const price = isProposal
              ? parseFloat(candle.close) 
              : parseFloat(candle.close) * 100;
            if (price <= 0 || price > 100) return false;
            
            if (interval !== '1m' && interval !== 'max') {
              // Handle time conversion: API may return seconds or milliseconds
              let timeMs: number;
              if (typeof candle.time === 'number') {
                // If time is less than year 2286 in seconds (1e12), it's in seconds
                if (candle.time < 1e12) {
                  timeMs = candle.time * 1000; // Convert seconds to milliseconds
                } else {
                  timeMs = candle.time; // Already in milliseconds
                }
              } else {
                const parsed = parseFloat(candle.time);
                timeMs = !isNaN(parsed) ? (parsed < 1e12 ? parsed * 1000 : parsed) : Date.now();
              }
              if (startTime > 0 && timeMs < startTime) return false;
            }
            
            return true;
          })
          .map((candle: any, index: number) => {
            // Handle time conversion: API may return seconds or milliseconds
            let timeMs: number;
            if (typeof candle.time === 'number') {
              // If time is less than year 2000 in milliseconds (946684800000), it's likely in seconds
              // If time is less than year 2286 in seconds (1e12), it's in seconds
              if (candle.time < 1e12) {
                timeMs = candle.time * 1000; // Convert seconds to milliseconds
              } else {
                timeMs = candle.time; // Already in milliseconds
              }
            } else {
              // String or other type - try to parse
              const parsed = parseFloat(candle.time);
              if (!isNaN(parsed)) {
                timeMs = parsed < 1e12 ? parsed * 1000 : parsed;
              } else {
                // Try parsing as ISO string
                const dateMs = new Date(candle.time).getTime();
                timeMs = isNaN(dateMs) ? Date.now() : dateMs;
              }
            }
            
            // For proposal markets, close is already in percentage (0-100)
            // For regular markets, convert from decimal (0-1) to percentage
            const price = isProposal
              ? parseFloat(candle.close) 
              : parseFloat(candle.close) * 100;
            
            return {
              time: timeMs,
              price: price,
              timestamp: new Date(timeMs).toISOString(),
              id: `candle-${candle.time}-${index}`,
            };
          })
          .sort((a: ChartDataPoint, b: ChartDataPoint) => a.time - b.time);
        
        if (points.length > 0) {
          const processedPoints = downsampleData(points, getMaxPoints);
          const lastPoint = processedPoints[processedPoints.length - 1];
          const now = Date.now();
          const stalenessMinutes = Math.floor((now - lastPoint.time) / (1000 * 60));
          setDataStaleness(stalenessMinutes);
          
          setChartData(processedPoints);
          setRetryCount(0);
          setError(null); // Clear any previous error when we have data
          hasDataRef.current = true;
          hasAttemptedFetchRef.current = true;
          setHasAttemptedFetch(true);
          isLoadingRef.current = false;
          setIsLoading(false);
          } else {
            setChartData([]);
            hasDataRef.current = false;
            hasAttemptedFetchRef.current = true;
            setHasAttemptedFetch(true);
            isLoadingRef.current = false;
            setIsLoading(false);
            // Don't set error here - let it be set only after we confirm no data in the else block
        }
      } else {
        // No data available - mark as attempted but DON'T set error here
        setChartData([]);
        hasDataRef.current = false;
        hasAttemptedFetchRef.current = true;
        setHasAttemptedFetch(true);
        isLoadingRef.current = false;
        setIsLoading(false);
        // Error will be set in finally block only after retries are exhausted
      }
      
    } catch (err: any) {
      console.error('❌ Error fetching market history:', err);
      setChartData([]);
      hasDataRef.current = false;
      hasAttemptedFetchRef.current = true;
      setHasAttemptedFetch(true);
      
      if (retryCount < 3) {
        // Don't set loading to false yet - we're retrying
        const delay = Math.min(1000 * Math.pow(2, retryCount), 8000);
        setTimeout(() => {
          setRetryCount(prev => prev + 1);
          const identifier = getAssetIdentifier(outcomeIdx);
          if (identifier) {
            fetchChartData(identifier, outcomeIdx);
          }
        }, delay);
      } else {
        // All retries exhausted - we're done loading
        isLoadingRef.current = false;
        setIsLoading(false);
        // Don't set error here - let finally block handle it
      }
    } finally {
      // Only update loading state if we're not retrying
      if (retryCount >= 3 || hasDataRef.current) {
        isLoadingRef.current = false;
      setIsLoading(false);
        // Only set error if we have no data and all retries are done
        if (!hasDataRef.current && retryCount >= 3) {
          // Use a small delay to ensure state updates are processed
          setTimeout(() => {
            if (!isLoadingRef.current && !hasDataRef.current) {
              setError('No trading history available for this market yet');
            }
          }, 50);
        }
      }
    }
  }, [interval, market, selectedOutcome, retryCount, getMaxPoints, downsampleData, getAssetIdentifier, isProposalMarket]);

  // Stabilize market identifier to prevent unnecessary rerenders
  const marketIdentifier = useMemo(() => {
    if (!market) return null;
    return getAssetIdentifier(actualIndex);
  }, [market?.proposalId, market?.proposal_id, market?.question_id, market?.clobTokenIds, market?.conditionId, selectedOutcome, isProposalMarket]);

  useEffect(() => {
    correctionAttemptedRef.current = {};
    setRetryCount(0);
    setDataStaleness(null);
    hasDataRef.current = false;
    hasAttemptedFetchRef.current = false;
    setHasAttemptedFetch(false);
    // Clear any previous error when changing outcome or interval
    setError(null);
    // Only reset animation state when interval changes (not when just switching outcomes)
    // For outcome switching, we want instant transition without reanimation
    if (interval) {
      // Only reset if interval actually changed (we'll track this separately)
      const intervalKey = `${interval}-${marketIdentifier || 'unknown'}`;
      if (lastAnimatedKeyRef.current && !lastAnimatedKeyRef.current.startsWith(intervalKey)) {
        lastAnimatedKeyRef.current = '';
      }
    }
  }, [interval, marketIdentifier]); // Removed selectedOutcome - don't reset animation on outcome switch

  useEffect(() => {
    if (!market) {
      // No market data provided
      setIsLoading(false);
      return;
    }
    
    // Only refetch if identifier actually changed
    if (!marketIdentifier) {
      // Silently handle missing identifier - some markets may not have token IDs yet
      setIsLoading(false);
      setError(null); // Don't show error, just don't display chart
      if (chartData.length === 0) {
        setChartData([]);
      }
      return;
    }
    
    // Don't set loading to true if we already have data - keep showing previous data
    // Only set loading if we have no data at all
    if (chartData.length === 0) {
      setIsLoading(true);
    }
    
    fetchChartData(marketIdentifier, actualIndex);
  }, [marketIdentifier, interval, actualIndex]); // Removed fetchChartData from deps - it's stable
  
  // Update container width on resize
  useEffect(() => {
    const updateWidth = () => {
      if (containerRef.current) {
        setContainerWidth(containerRef.current.offsetWidth);
      }
    };
    
    updateWidth();
    window.addEventListener('resize', updateWidth);
    return () => window.removeEventListener('resize', updateWidth);
  }, []);

  const enhancedChartData = useMemo(() => {
    if (chartData.length === 0) return [];
    
    let data = [...chartData];
    
    if (data.length < 3) {
      const lastPoint = data[data.length - 1];
      const now = Date.now();
      const timeSinceLastPoint = now - lastPoint.time;
      
      if (Math.abs(lastPoint.price - currentPrice) > 0.5 || timeSinceLastPoint > 3600000) {
        data.push({
          time: now,
          price: currentPrice,
          timestamp: new Date(now).toISOString(),
          id: `current-${now}`,
        });
      }
    }
    
    return data;
  }, [chartData, currentPrice]);
  
  const formatTime = (tickItem: number) => {
    if (!tickItem) return '';
    const date = new Date(tickItem);
    
    switch (interval) {
      case '1h':
      case '6h':
        return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: false });
      case '1d':
        return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      case '1w':
      case '1m':
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      case 'max':
        return date.toLocaleDateString('en-US', { month: 'short' });
      default:
        return date.toLocaleDateString('en-US', { month: 'short' });
    }
  };

  // Use site's brand blue for YES, red for NO (maintains prediction market convention)
  const lineColor = selectedOutcome === 'YES' 
    ? 'var(--accent-primary)'  // Site's brand blue
    : 'var(--accent-red)';  // Red for NO

  const priceChangePercent = useMemo(() => {
    if (enhancedChartData.length < 2) return 0;
    const firstPrice = enhancedChartData[0].price;
    const lastPrice = enhancedChartData[enhancedChartData.length - 1].price;
    return ((lastPrice - firstPrice) / firstPrice) * 100;
  }, [enhancedChartData]);

  // Visx tooltip
  const {
    tooltipData,
    tooltipLeft,
    tooltipTop,
    tooltipOpen,
    showTooltip,
    hideTooltip,
  } = useTooltip<ChartDataPoint>();

  // Calculate chart dimensions first (needed for scales and effects)
  // Responsive margins - smaller on mobile for better chart size
  const isMobile = containerWidth < 640;
  const margin = { 
    top: 10, 
    right: isMobile ? 20 : 40, 
    bottom: 25, 
    left: 0 
  };
  const innerWidth = containerWidth - margin.left - margin.right;
  const innerHeight = height - margin.top - margin.bottom;

  // Hover state
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
  const hoveredPrice = hoveredIndex !== null && enhancedChartData[hoveredIndex] 
    ? enhancedChartData[hoveredIndex].price 
    : null;
  
  // Simple animation - just track what we've animated
  const pathGroupRef = useRef<SVGGElement | null>(null);
  const [showCircle, setShowCircle] = useState(false);
  const lastAnimatedKeyRef = useRef<string>('');
  const lastOutcomeRef = useRef<'YES' | 'NO'>(selectedOutcome);
  const lastDataKeyRef = useRef<string>('');
  
  // Create key from current state (excluding selectedOutcome for proposal markets)
  // For proposal markets, YES/NO use the same data, so we don't want to reanimate on outcome switch
  const dataKey = useMemo(() => {
    if (enhancedChartData.length === 0 || isLoading) return null;
    const first = enhancedChartData[0]?.time || 0;
    const last = enhancedChartData[enhancedChartData.length - 1]?.time || 0;
    // Don't include selectedOutcome in key for proposal markets (same data, just different view)
    // Only include it for non-proposal markets where YES/NO have different data
    if (isProposalMarket) {
      return `${interval}-${enhancedChartData.length}-${first}-${last}`;
    }
    return `${interval}-${selectedOutcome}-${enhancedChartData.length}-${first}-${last}`;
  }, [enhancedChartData, interval, selectedOutcome, isLoading, isProposalMarket]);
  
  // Create data-only key (without outcome) to detect if only outcome changed
  const dataOnlyKey = useMemo(() => {
    if (enhancedChartData.length === 0 || isLoading) return null;
    const first = enhancedChartData[0]?.time || 0;
    const last = enhancedChartData[enhancedChartData.length - 1]?.time || 0;
    return `${interval}-${enhancedChartData.length}-${first}-${last}`;
  }, [enhancedChartData, interval, isLoading]);
  
  // Track outcome changes to reset animation
  useEffect(() => {
    if (lastOutcomeRef.current !== selectedOutcome) {
      // Outcome changed - reset animation key so new path will animate
      lastAnimatedKeyRef.current = '';
      lastOutcomeRef.current = selectedOutcome;
    }
  }, [selectedOutcome]);
  
  // Animate when data key changes
  useEffect(() => {
    if (!dataKey || !dataOnlyKey) {
      return;
    }
    
    // For proposal markets, if same data key, show immediately (outcome change doesn't affect data)
    if (isProposalMarket && dataKey === lastAnimatedKeyRef.current) {
      setShowCircle(true);
      const path = pathGroupRef.current?.querySelector('path');
      if (path) {
        path.style.strokeDasharray = 'none';
        path.style.strokeDashoffset = '0';
        path.style.visibility = 'visible';
        path.style.opacity = '1';
        path.style.willChange = 'auto';
      }
      return;
    }
    
    // If same data key, show immediately
    if (dataKey === lastAnimatedKeyRef.current) {
      setShowCircle(true);
      const path = pathGroupRef.current?.querySelector('path');
      if (path) {
        path.style.strokeDasharray = 'none';
        path.style.strokeDashoffset = '0';
        path.style.visibility = 'visible';
        path.style.willChange = 'auto';
      }
      lastDataKeyRef.current = dataOnlyKey;
      return;
    }
    
    // New data - animate
    lastAnimatedKeyRef.current = dataKey;
    lastOutcomeRef.current = selectedOutcome;
    lastDataKeyRef.current = dataOnlyKey;
    setShowCircle(false);
    
    // Use requestAnimationFrame for better performance
    const setupAnimation = () => {
      const group = pathGroupRef.current;
      const path = group?.querySelector('path');
      if (!group || !path) {
        // Retry once if not ready
        requestAnimationFrame(setupAnimation);
        return;
      }
      
      const length = path.getTotalLength();
      if (length === 0) {
        // Path not ready, retry once more
        requestAnimationFrame(() => {
          const retryPath = pathGroupRef.current?.querySelector('path');
          if (retryPath) {
            const retryLength = retryPath.getTotalLength();
            if (retryLength > 0) {
              startAnimation(group, retryPath, retryLength);
            } else {
              // Still not ready, show without animation
              setShowCircle(true);
              retryPath.style.strokeDasharray = 'none';
              retryPath.style.strokeDashoffset = '0';
              retryPath.style.visibility = 'visible';
            }
          }
        });
        return;
      }
      
      startAnimation(group, path, length);
    };
    
    requestAnimationFrame(setupAnimation);
    
    function startAnimation(group: SVGGElement, path: SVGPathElement, length: number) {
      group.classList.remove('line-initial-hidden');
      
      // Set initial state
      path.style.strokeDasharray = `${length}`;
      path.style.strokeDashoffset = `${length}`;
      path.style.visibility = 'visible';
      path.style.willChange = 'stroke-dashoffset';
      path.style.transition = 'none';
      
      // Start animation with optimized timing (0.6s for snappier feel)
      const animationDuration = 600; // 0.6 seconds
      
      // Use requestAnimationFrame to ensure initial state is painted before animation
      requestAnimationFrame(() => {
        path.style.transition = `stroke-dashoffset ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`;
        path.style.strokeDashoffset = '0';
        
        // Show circle exactly when animation completes
        setTimeout(() => {
          setShowCircle(true);
          path.style.strokeDasharray = 'none';
          path.style.strokeDashoffset = '0';
          path.style.transition = '';
          path.style.willChange = 'auto';
        }, animationDuration);
      });
    }
  }, [dataKey]);

  // Create scales - always provide valid scales even when loading
  const xScale = useMemo(() => {
    if (enhancedChartData.length === 0 || isLoading) {
      // Use placeholder time range when loading
      const now = Date.now();
      const intervals = { '1h': 3600000, '6h': 21600000, '1d': 86400000, '1w': 604800000, '1m': 2592000000, 'max': 7776000000 };
      const range = intervals[interval] || intervals['max'];
      const startTime = now - range;
      return scaleTime({
        range: [0, innerWidth],
        domain: [startTime, now],
      });
    }
    
    const times = enhancedChartData.map(d => d.time);
    return scaleTime({
      range: [0, innerWidth],
      domain: [Math.min(...times), Math.max(...times)],
    });
  }, [enhancedChartData, innerWidth, isLoading, interval]);

  const yScale = useMemo(() => {
    // Always use 0-100 domain for consistent axis rendering
    return scaleLinear({
      range: [innerHeight, 0],
      domain: [0, 100],
    });
  }, [innerHeight]);

  // Handle mouse move for hover
  const handleMouseMove = useCallback((event: React.MouseEvent<SVGSVGElement>) => {
    if (!containerRef.current || enhancedChartData.length === 0) return;
    
    const coords = localPoint(containerRef.current, event);
    if (!coords) return;
    
    const x = coords.x - margin.left;
    const x0 = xScale.invert(x);
    const x0Time = x0 instanceof Date ? x0.getTime() : Number(x0);
    
    // Find closest data point
    const bisectDate = bisector<ChartDataPoint, number>(d => d.time).left;
    const index = bisectDate(enhancedChartData, x0Time, 1);
    const a = enhancedChartData[index - 1];
    const b = enhancedChartData[index];
    
    if (!b) return;
    
    const d = b && a ? (x0Time - a.time > b.time - x0Time ? b : a) : b;
    const indexOfD = enhancedChartData.indexOf(d);
    
    if (indexOfD >= 0) {
      setHoveredIndex(indexOfD);
      const y = yScale(d.price);
      showTooltip({
        tooltipLeft: x + margin.left,
        tooltipTop: y + margin.top,
        tooltipData: d,
      });
    }
  }, [enhancedChartData, xScale, yScale, showTooltip]);

  const handleMouseLeave = useCallback(() => {
    setHoveredIndex(null);
    hideTooltip();
  }, [hideTooltip]);

  // Split data for hover effect
  const highlightedData = useMemo(() => {
    if (hoveredIndex === null || enhancedChartData.length === 0) {
      return enhancedChartData;
    }
    return enhancedChartData.slice(0, hoveredIndex + 1);
  }, [enhancedChartData, hoveredIndex]);

  const dimmedData = useMemo(() => {
    if (hoveredIndex === null || enhancedChartData.length === 0) {
      return [];
    }
    return enhancedChartData.slice(hoveredIndex);
  }, [enhancedChartData, hoveredIndex]);

  // Generate path data
  const getX = (d: ChartDataPoint) => xScale(d.time);
  const getY = (d: ChartDataPoint) => yScale(d.price);

  const markerId = useMemo(() => `end-marker-${Math.random().toString(36).substr(2, 9)}`, []);

  return (
    <div 
      className={`flex flex-col w-full ${isEmbed ? '' : ''} h-auto`}
      style={{ 
        '--chart-height': `${height}px`,
        marginBottom: '0',
        paddingBottom: '0',
      } as React.CSSProperties}
    >
      <style>{`
        @media (max-width: 639px) {
          .outcome-selector-mobile-hidden {
            display: none !important;
          }
        }
      `}</style>
      {/* Price Display Section */}
      <div className={`flex flex-col sm:flex-row sm:items-center gap-2 ${isEmbed ? 'mb-1' : 'mb-2'}`}>
        <div className="flex flex-col relative">
          <div className="font-semibold flex flex-row items-center gap-2 flex-wrap">
            <span 
              className={isEmbed ? "text-lg" : "text-xl lg:text-2xl"} 
              style={{ color: lineColor }}
            >
              {selectedOutcome} {(hoveredPrice !== null ? hoveredPrice : currentPrice).toFixed(1)}% chance
            </span>
            {Math.abs(priceChangePercent) > 0.01 && enhancedChartData.length >= 2 && (
              <div className="flex items-center gap-0.5">
                <svg xmlns="http://www.w3.org/2000/svg" width={isEmbed ? "10" : "12"} height={isEmbed ? "10" : "12"} viewBox="0 0 12 12">
                  <g fill={priceChangePercent < 0 ? "var(--accent-red)" : "var(--accent-primary)"}>
                    <path d="m9.099,2.5H2.901c-.554,0-1.061.303-1.322.792-.262.488-.233,1.079.074,1.54l3.099,4.648c.279.418.745.668,1.248.668s.969-.25,1.248-.668l3.099-4.648c.308-.461.336-1.051.074-1.54-.262-.489-.769-.792-1.322-.792Z" strokeWidth="0" transform={priceChangePercent > 0 ? "rotate(180 6 6)" : ""}></path>
                  </g>
                </svg>
                <span 
                  className={isEmbed ? "text-[10px]" : "text-xs"} 
                  style={{ 
                    color: priceChangePercent < 0 ? 'var(--accent-red)' : 'var(--accent-primary)',
                    fontSize: isEmbed ? '9px' : '11px'
                  }}
                >
                  {Math.abs(priceChangePercent).toFixed(1)}%
                </span>
              </div>
            )}
            {market?.averageMarketShares && market.averageMarketShares > 0 && market.polymarketPrice !== null && market.polymarketPrice !== undefined && (() => {
              // averageMarketShares represents shares of the reference Polymarket market
              // ONLY use the Polymarket price for the specific outcome being traded (YES or NO)
              // This is passed as polymarketPrice from the parent component - no fallbacks
              const priceForCalculation = market.polymarketPrice;
              
              return (
                <div className="flex flex-col sm:flex-row sm:items-center gap-1 sm:gap-2 w-full sm:w-auto">
                  <span 
                    className="text-sm lg:text-base font-medium whitespace-nowrap" 
                    style={{ color: 'var(--accent-primary)' }}
                  >
                    • Avg: {market.averageMarketShares.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}{' '}
                    <span style={{ color: market.tradedOutcome === 'YES' ? 'var(--accent-primary)' : 'var(--accent-red)' }}>
                      {market.tradedOutcome || 'YES'}
                    </span>
                    {' '}shares
                  </span>
                  <span 
                    className="text-sm lg:text-base font-medium whitespace-nowrap" 
                    style={{ color: 'var(--text-secondary)' }}
                  >
                    (≈ ${(market.averageMarketShares * priceForCalculation).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} USD) if passed
                  </span>
                </div>
              );
            })()}
          </div>
        </div>
        
        {/* Outcome selector - Hidden on mobile, shown on desktop */}
        {outcomes.length >= 2 && (
          <div className="hidden sm:inline-flex dao-button-toggle-group ml-auto outcome-selector-mobile-hidden">
            {outcomes.map((outcome: string, idx: number) => {
              const isYes = outcome.toUpperCase() === 'YES' || outcome.toUpperCase() === 'TRUE' || idx === 0;
              const isSelected = (isYes && selectedOutcome === 'YES') || (!isYes && selectedOutcome === 'NO');
              const outcomeLabel = isYes ? 'YES' : 'NO';
              
              return (
                <button
                  key={outcome}
                  onClick={() => setSelectedOutcome(isYes ? 'YES' : 'NO')}
                  className={`${isEmbed ? 'dao-button-toggle-small' : 'dao-button-toggle'} ${isSelected ? `active ${!isYes ? 'red' : ''}` : ''}`}
                >
                  {outcomeLabel}
                </button>
              );
            })}
          </div>
        )}
      </div>

      {/* Chart Container */}
      <div 
        ref={containerRef}
        id="group-chart-container" 
        className={`flex min-w-full w-full max-w-full sm:min-w-0 relative box-border ${isEmbed ? 'mt-2' : 'mt-7'}`}
        style={{ 
          height: `${height}px`,
          minHeight: `${height}px`,
          width: '100%',
        } as React.CSSProperties}
      >
        {/* Always render chart structure, show error overlay if needed */}
        <svg width={containerWidth} height={height} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave} style={{ position: 'relative', overflow: 'visible' }}>
            <defs>
              <marker
                id={markerId}
                markerWidth="0"
                markerHeight="0"
                refX="9.875"
                refY="9.875"
                orient="auto-start-reverse"
                markerUnits="strokeWidth"
                strokeWidth="1.75"
                opacity={hoveredIndex === null && showCircle ? '1' : (hoveredIndex === null ? '0' : '0.3')}
                fill={lineColor}
                stroke={lineColor}
                className="pointer-events-auto overflow-visible"
              >
                <circle r="1.5" cx="9.875" cy="9.875" fill={lineColor} stroke={lineColor} />
                <circle r="6" cx="9.875" cy="9.875" fill="transparent" stroke="transparent" />
                <circle 
                  r="6" 
                  cx="9.875" 
                  cy="9.875" 
                  fill={lineColor} 
                  opacity={hoveredIndex === null && showCircle ? '0.19' : '0'}
                  style={{ transform: 'scale(0.809259)', transformOrigin: '50% 50%', transformBox: 'fill-box' }}
                />
              </marker>
              {/* Animation styles */}
              <style>{`
                .line-initial-hidden {
                  visibility: hidden;
                }
              `}</style>
            </defs>
            
            <g transform={`translate(${margin.left},${margin.top})`}>
              {/* Grid lines - always visible */}
              <GridRows
                scale={yScale}
                width={innerWidth}
                strokeDasharray="1,3"
                stroke="#344452"
                strokeWidth={1}
                numTicks={5}
              />
              
              {/* X Axis - always visible */}
              <AxisBottom
                top={innerHeight}
                scale={xScale}
                tickFormat={(value) => {
                  const timeValue = value instanceof Date ? value.getTime() : Number(value);
                  return formatTime(timeValue);
                }}
                stroke="transparent"
                tickStroke="transparent"
                tickLabelProps={() => ({
                  fill: '#858D92',
                  fontSize: isEmbed ? 9 : 11,
                  fontFamily: 'Arial, sans-serif',
                  fontWeight: 400,
                  textAnchor: 'middle',
                })}
                numTicks={isEmbed ? 4 : (innerWidth < 400 ? 3 : innerWidth < 600 ? 4 : innerWidth < 800 ? 5 : 6)} // Responsive ticks to prevent clustering on mobile
              />
              
              {/* Y Axis - always visible */}
              <AxisRight
                left={innerWidth}
                scale={yScale}
                tickFormat={(value) => `${value}%`}
                stroke="transparent"
                tickStroke="transparent"
                tickLabelProps={() => ({
                  fill: '#858D92',
                  fontSize: isEmbed ? 9 : 11,
                  fontFamily: 'Arial, sans-serif',
                  fontWeight: 400,
                  textAnchor: 'start',
                  dx: '0.25em',
                })}
                tickValues={isEmbed ? [0, 50, 100] : [0, 20, 40, 60, 80, 100]}
              />
              
              {/* Highlighted line - show if we have data, even if loading new data */}
              {highlightedData.length > 0 && (
                <g ref={pathGroupRef} key={`line-${selectedOutcome}-${dataOnlyKey || 'loading'}`}>
                  <LinePath
                    data={highlightedData}
                    x={getX}
                    y={getY}
                    stroke={lineColor}
                    strokeWidth={1.75}
                    strokeOpacity={1}
                    curve={curveMonotoneX}
                    markerEnd={hoveredIndex === null && showCircle ? `url(#${markerId})` : undefined}
                  />
                </g>
              )}
              
              {/* Dimmed line (when hovering) - render AFTER highlighted line so it appears on top but dimmed */}
              {hoveredIndex !== null && dimmedData.length > 0 && (
                <LinePath
                  data={dimmedData}
                  x={getX}
                  y={getY}
                  stroke={lineColor}
                  strokeWidth={1.75}
                  strokeOpacity={0.25}
                  curve={curveMonotoneX}
                />
              )}
              
              {/* Vertical line on hover - show if we have data */}
              {tooltipOpen && tooltipLeft && tooltipData && (
                <g>
                  <line
                    x1={tooltipLeft - margin.left}
                    y1={0}
                    x2={tooltipLeft - margin.left}
                    y2={innerHeight}
                    stroke={lineColor}
                    strokeWidth={1.5}
                    strokeDasharray="2,4"
                    opacity={0.4}
                    style={{ pointerEvents: 'none' }}
                  />
                  <circle
                    cx={tooltipLeft - margin.left}
                    cy={tooltipTop ? tooltipTop - margin.top : 0}
                    r={6}
                    fill={lineColor}
                    stroke="var(--color-background)"
                    strokeWidth={3}
                    style={{ pointerEvents: 'none' }}
                  />
                  <circle
                    cx={tooltipLeft - margin.left}
                    cy={tooltipTop ? tooltipTop - margin.top : 0}
                    r={1.5}
                    fill={lineColor}
                    style={{ pointerEvents: 'none' }}
                  />
                </g>
              )}
            </g>
          </svg>
          
          {/* Error overlay - ONLY show when NOT loading, have attempted fetch, have no data, AND error exists */}
          {/* CRITICAL: isLoading check FIRST - if loading, NEVER show error */}
          {!isLoading && !isLoadingRef.current && !hasDataRef.current && error && chartData.length === 0 && hasAttemptedFetchRef.current && (
            <div className="absolute inset-0 flex items-center justify-center bg-[var(--color-background)] bg-opacity-90">
            <div className="text-center">
              <p className="text-sm mb-3" style={{ color: 'var(--accent-red)' }}>{error}</p>
              {retryCount >= 3 && (
                <button
                  onClick={() => {
                    setRetryCount(0);
                    const identifier = getAssetIdentifier(actualIndex);
                    if (identifier) {
                      fetchChartData(identifier, actualIndex);
                    }
                  }}
                    className="px-4 py-2 text-sm rounded-lg font-medium transition-all mx-auto block"
                  style={{ backgroundColor: lineColor, color: 'white' }}
                >
                  Retry
                </button>
              )}
            </div>
          </div>
          )}
        
        {/* Tooltip */}
        {tooltipOpen && tooltipData && (
          <TooltipWithBounds
            left={tooltipLeft}
            top={tooltipTop ? tooltipTop - 40 : 0}
                style={{ 
              ...defaultStyles,
              backgroundColor: 'var(--color-background)',
              border: '1px solid var(--bg-hover)',
              borderRadius: '6px',
              padding: '4px 8px',
                  fontSize: '11px',
                  fontFamily: 'Arial, sans-serif',
              color: 'var(--text-primary)',
              boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
            }}
          >
            <div style={{ fontWeight: 500, marginBottom: '2px' }}>
              {tooltipData.price.toFixed(1)}% chance
            </div>
            {market?.averageMarketShares && market.averageMarketShares > 0 && market.polymarketPrice !== null && market.polymarketPrice !== undefined && (() => {
              // averageMarketShares represents shares of the reference Polymarket market
              // ONLY use the Polymarket price for the specific outcome being traded (YES or NO)
              // This is passed as polymarketPrice from the parent component - no fallbacks
              const priceForCalculation = market.polymarketPrice;
              
              return (
                <div className="text-xs" style={{ color: 'var(--accent-primary)', marginTop: '2px', whiteSpace: 'nowrap' }}>
                  Avg: {market.averageMarketShares.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}{' '}
                  <span style={{ color: market.tradedOutcome === 'YES' ? 'var(--accent-primary)' : 'var(--accent-red)' }}>
                    {market.tradedOutcome || 'YES'}
                  </span>
                  {' '}shares
                  <span style={{ color: 'var(--text-secondary)' }}>
                    {' '}(≈ ${(market.averageMarketShares * priceForCalculation).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} USD)
                  </span>
                  {' '}if passed
                </div>
              );
            })()}
            <div className="text-xs" style={{ color: 'var(--text-tertiary)', marginTop: '2px' }}>
              {new Date(tooltipData.time).toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
              })}
            </div>
          </TooltipWithBounds>
        )}
      </div>

      {/* Tab Buttons */}
      {!hideIntervalSelector && (
        <div className="mt-4 mb-0 flex items-center justify-between gap-3">
          <div className="relative inline-flex justify-center text-zinc-500 group rounded-lg p-1 !text-sm bg-transparent z-[3] gap-0.5 h-[30px] items-start overflow-hidden pl-0">
            {(['1h', '6h', '1d', '1w', '1m', 'max'] as const).map((iv) => {
              const isActive = interval === iv;
              return (
                <button
                  key={iv}
                  onClick={() => setInterval(iv)}
                  className="inline-flex cursor-pointer z-[1] h-full items-center justify-center whitespace-nowrap rounded-md py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 uppercase !text-[13px] px-2.5"
                  style={{
                    color: isActive ? 'var(--text-primary)' : 'var(--text-tertiary)',
                  }}
                >
                  {iv === 'max' ? 'ALL' : iv.toUpperCase()}
                </button>
              );
            })}
            <div 
              className="absolute pointer-events-none top-1/2 -translate-y-1/2 rounded-[4px] h-7 bg-tabs-highlight-bg"
              style={{
                left: `${(['1h', '6h', '1d', '1w', '1m', 'max'] as const).indexOf(interval) * 43.0938}px`,
                width: '43.0938px',
                opacity: 1,
              }}
            />
          </div>
          
          {/* Outcome Switch - Mobile only, next to interval selector */}
          {outcomes.length >= 2 && (
            <button
              onClick={() => setSelectedOutcome(selectedOutcome === 'YES' ? 'NO' : 'YES')}
              className="sm:hidden inline-flex items-center cursor-pointer active:scale-[97%] transition justify-center gap-2 whitespace-nowrap rounded-sm !text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 h-8 w-8"
              style={{
                backgroundColor: 'var(--bg-hover)',
                color: 'var(--text-secondary)',
              }}
              title={`Switch to ${selectedOutcome === 'YES' ? 'NO' : 'YES'}`}
            >
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18">
                <title>arrows-cross</title>
                <g fill="none" strokeLinecap="round" strokeLinejoin="round" strokeWidth="1.5" stroke="currentColor">
                  <polyline stroke="currentColor" points="10.75 15.25 15.25 15.25 15.25 10.75"></polyline>
                  <line stroke="currentColor" x1="7" y1="7" x2="2.75" y2="2.75"></line>
                  <line stroke="currentColor" x1="15.25" y1="15.25" x2="11" y2="11"></line>
                  <polyline stroke="currentColor" points="10.75 2.75 15.25 2.75 15.25 7.25"></polyline>
                  <line stroke="currentColor" x1="15.25" y1="2.75" x2="2.75" y2="15.25"></line>
                </g>
              </svg>
            </button>
          )}
        </div>
      )}
    </div>
  );
}
